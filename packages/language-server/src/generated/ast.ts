/******************************************************************************
 * This file was generated by langium-cli 1.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type AbstractElementStyleProperty = ElementShapeStyleProperty;

export const AbstractElementStyleProperty = 'AbstractElementStyleProperty';

export function isAbstractElementStyleProperty(item: unknown): item is AbstractElementStyleProperty {
    return reflection.isInstance(item, AbstractElementStyleProperty);
}

export type ElementProperty = ElementStringProperty | ElementStyleProperty;

export const ElementProperty = 'ElementProperty';

export function isElementProperty(item: unknown): item is ElementProperty {
    return reflection.isInstance(item, ElementProperty);
}

export type ElementShape = 'browser' | 'cylinder' | 'person' | 'queue' | 'rectangle' | 'storage';

export type Name = ElementShape | string;

export interface Element extends AstNode {
    readonly $container: ElementBody | ExtendElement | Model;
    readonly $type: 'Element';
    definition?: ElementBody
    kind: Reference<ElementKind>
    name: Name
    title?: string
}

export const Element = 'Element';

export function isElement(item: unknown): item is Element {
    return reflection.isInstance(item, Element);
}

export interface ElementBody extends AstNode {
    readonly $container: Element;
    readonly $type: 'ElementBody';
    elements: Array<Element | Relation>
    props: Array<ElementProperty>
    tags?: Tags
}

export const ElementBody = 'ElementBody';

export function isElementBody(item: unknown): item is ElementBody {
    return reflection.isInstance(item, ElementBody);
}

export interface ElementKind extends AstNode {
    readonly $container: SpecificationElementKind;
    readonly $type: 'ElementKind';
    name: Name
}

export const ElementKind = 'ElementKind';

export function isElementKind(item: unknown): item is ElementKind {
    return reflection.isInstance(item, ElementKind);
}

export interface ElementRef extends AstNode {
    readonly $container: ElementRef | Relation | RelationWithSource;
    readonly $type: 'ElementRef';
    el: Reference<Element>
    next?: ElementRef
}

export const ElementRef = 'ElementRef';

export function isElementRef(item: unknown): item is ElementRef {
    return reflection.isInstance(item, ElementRef);
}

export interface ElementShapeStyleProperty extends AstNode {
    readonly $container: ElementStyleProperties;
    readonly $type: 'ElementShapeStyleProperty';
    key: 'shape'
    value: ElementShape
}

export const ElementShapeStyleProperty = 'ElementShapeStyleProperty';

export function isElementShapeStyleProperty(item: unknown): item is ElementShapeStyleProperty {
    return reflection.isInstance(item, ElementShapeStyleProperty);
}

export interface ElementStringProperty extends AstNode {
    readonly $container: ElementBody;
    readonly $type: 'ElementStringProperty';
    key: 'description' | 'title'
    value: string
}

export const ElementStringProperty = 'ElementStringProperty';

export function isElementStringProperty(item: unknown): item is ElementStringProperty {
    return reflection.isInstance(item, ElementStringProperty);
}

export interface ElementStyleProperties extends AstNode {
    readonly $container: ElementStyleProperty | SpecificationElementKind;
    readonly $type: 'ElementStyleProperties';
    props: Array<AbstractElementStyleProperty>
}

export const ElementStyleProperties = 'ElementStyleProperties';

export function isElementStyleProperties(item: unknown): item is ElementStyleProperties {
    return reflection.isInstance(item, ElementStyleProperties);
}

export interface ElementStyleProperty extends AstNode {
    readonly $container: ElementBody;
    readonly $type: 'ElementStyleProperty';
    key: 'style'
    value: ElementStyleProperties
}

export const ElementStyleProperty = 'ElementStyleProperty';

export function isElementStyleProperty(item: unknown): item is ElementStyleProperty {
    return reflection.isInstance(item, ElementStyleProperty);
}

export interface ExtendElement extends AstNode {
    readonly $container: Model;
    readonly $type: 'ExtendElement';
    element: StrictElementRef
    elements: Array<Element | RelationWithSource>
}

export const ExtendElement = 'ExtendElement';

export function isExtendElement(item: unknown): item is ExtendElement {
    return reflection.isInstance(item, ExtendElement);
}

export interface LikeC4Document extends AstNode {
    readonly $type: 'LikeC4Document';
    model?: Model
    specification?: SpecificationRule
}

export const LikeC4Document = 'LikeC4Document';

export function isLikeC4Document(item: unknown): item is LikeC4Document {
    return reflection.isInstance(item, LikeC4Document);
}

export interface Model extends AstNode {
    readonly $container: LikeC4Document;
    readonly $type: 'Model';
    elements: Array<Element | ExtendElement | RelationWithSource>
    name: 'model'
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface Relation extends AstNode {
    readonly $container: ElementBody | ExtendElement | Model;
    readonly $type: 'Relation' | 'RelationWithSource';
    target: ElementRef
    title?: string
}

export const Relation = 'Relation';

export function isRelation(item: unknown): item is Relation {
    return reflection.isInstance(item, Relation);
}

export interface SpecificationElementKind extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationElementKind';
    kind: ElementKind
    style?: ElementStyleProperties
}

export const SpecificationElementKind = 'SpecificationElementKind';

export function isSpecificationElementKind(item: unknown): item is SpecificationElementKind {
    return reflection.isInstance(item, SpecificationElementKind);
}

export interface SpecificationRule extends AstNode {
    readonly $container: LikeC4Document;
    readonly $type: 'SpecificationRule';
    elementKinds: Array<SpecificationElementKind>
    name: 'specification'
    tags: Array<SpecificationTag>
}

export const SpecificationRule = 'SpecificationRule';

export function isSpecificationRule(item: unknown): item is SpecificationRule {
    return reflection.isInstance(item, SpecificationRule);
}

export interface SpecificationTag extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationTag';
    tag: Tag
}

export const SpecificationTag = 'SpecificationTag';

export function isSpecificationTag(item: unknown): item is SpecificationTag {
    return reflection.isInstance(item, SpecificationTag);
}

export interface StrictElementRef extends AstNode {
    readonly $container: ExtendElement | StrictElementRef;
    readonly $type: 'StrictElementRef';
    el: Reference<Element>
    next?: StrictElementRef
}

export const StrictElementRef = 'StrictElementRef';

export function isStrictElementRef(item: unknown): item is StrictElementRef {
    return reflection.isInstance(item, StrictElementRef);
}

export interface Tag extends AstNode {
    readonly $container: SpecificationTag;
    readonly $type: 'Tag';
    name: Name
}

export const Tag = 'Tag';

export function isTag(item: unknown): item is Tag {
    return reflection.isInstance(item, Tag);
}

export interface Tags extends AstNode {
    readonly $container: ElementBody;
    readonly $type: 'Tags';
    value: Array<Reference<Tag>>
}

export const Tags = 'Tags';

export function isTags(item: unknown): item is Tags {
    return reflection.isInstance(item, Tags);
}

export interface RelationWithSource extends Relation {
    readonly $container: ElementBody | ExtendElement | Model;
    readonly $type: 'RelationWithSource';
    source: ElementRef
    target: ElementRef
    title?: string
}

export const RelationWithSource = 'RelationWithSource';

export function isRelationWithSource(item: unknown): item is RelationWithSource {
    return reflection.isInstance(item, RelationWithSource);
}

export interface LikeC4AstType {
    AbstractElementStyleProperty: AbstractElementStyleProperty
    Element: Element
    ElementBody: ElementBody
    ElementKind: ElementKind
    ElementProperty: ElementProperty
    ElementRef: ElementRef
    ElementShapeStyleProperty: ElementShapeStyleProperty
    ElementStringProperty: ElementStringProperty
    ElementStyleProperties: ElementStyleProperties
    ElementStyleProperty: ElementStyleProperty
    ExtendElement: ExtendElement
    LikeC4Document: LikeC4Document
    Model: Model
    Relation: Relation
    RelationWithSource: RelationWithSource
    SpecificationElementKind: SpecificationElementKind
    SpecificationRule: SpecificationRule
    SpecificationTag: SpecificationTag
    StrictElementRef: StrictElementRef
    Tag: Tag
    Tags: Tags
}

export class LikeC4AstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AbstractElementStyleProperty', 'Element', 'ElementBody', 'ElementKind', 'ElementProperty', 'ElementRef', 'ElementShapeStyleProperty', 'ElementStringProperty', 'ElementStyleProperties', 'ElementStyleProperty', 'ExtendElement', 'LikeC4Document', 'Model', 'Relation', 'RelationWithSource', 'SpecificationElementKind', 'SpecificationRule', 'SpecificationTag', 'StrictElementRef', 'Tag', 'Tags'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case ElementShapeStyleProperty: {
                return this.isSubtype(AbstractElementStyleProperty, supertype);
            }
            case ElementStringProperty:
            case ElementStyleProperty: {
                return this.isSubtype(ElementProperty, supertype);
            }
            case RelationWithSource: {
                return this.isSubtype(Relation, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Element:kind': {
                return ElementKind;
            }
            case 'ElementRef:el':
            case 'StrictElementRef:el': {
                return Element;
            }
            case 'Tags:value': {
                return Tag;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'ElementBody': {
                return {
                    name: 'ElementBody',
                    mandatory: [
                        { name: 'elements', type: 'array' },
                        { name: 'props', type: 'array' }
                    ]
                };
            }
            case 'ElementStyleProperties': {
                return {
                    name: 'ElementStyleProperties',
                    mandatory: [
                        { name: 'props', type: 'array' }
                    ]
                };
            }
            case 'ExtendElement': {
                return {
                    name: 'ExtendElement',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'SpecificationRule': {
                return {
                    name: 'SpecificationRule',
                    mandatory: [
                        { name: 'elementKinds', type: 'array' },
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'Tags': {
                return {
                    name: 'Tags',
                    mandatory: [
                        { name: 'value', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new LikeC4AstReflection();
