import {  Steps, Callout } from 'nextra-theme-docs'

# Getting Started

LikeC4 inherits the ideas of [C4 Model](https://c4model.com/) and [Structurizr DSL](https://structurizr.com/).

Based on "software architecture as code" approach, it allows to define architecture model in a text file and automaticallty generate various views from it.  
That means you can keep your architecture model in the repository, review changes, track history and compare generated views.

The three pillars:

- `specification` - you are free to go beyond C4 layers and define your own element kinds, like `app`, `microservice` and so on
- `model` - architecture elements, hierarchies, conmpositions and relationships
- `views` - visual "projections" of the model from different perspectives (by filtering with predicates)

Any change in the model is reflected everywhere automatically.   
Rename elements, update descriptions, mark as deprecated or add/remove relationships -  and all views are updated automatically.

Various ways to play and learn the tool:
- Install [official VSCode extension](https://marketplace.visualstudio.com/items?itemName=likec4.likec4-vscode)
- Online [playground](/playground/)
- With [github.dev](https://github.dev/likec4/example-cloud-system/blob/main/model.c4) 
- With [vscode.dev](https://vscode.dev/github/likec4/example-cloud-system/blob/main/model.c4) 

Be sure you agree and install the recommended extension if you pick last two options.

## Tutorial

<Steps>

### Tailor your model

We start with defining the kinds we want to use in our model.  
For now we want only two - `actor` and `system`

```likec4 showLineNumbers filename="getting-started.c4" 
specification {
  element actor
  element system
}
```

### Define base model

Start with top-level elements

```likec4 showLineNumbers filename="getting-started.c4" 
specification {
  element actor
  element system
}

model {
  customer = actor 'Customer'
  saas = system 'Our SaaS'
}
```

### Add nested elements

Assume the system has two main components - `ui` and `backend`.  
We add new element kind - `component` and update the model.

```likec4 showLineNumbers {4,10-11}  filename="getting-started.c4" 
specification {
  element actor
  element system
  element component
}

model {
  customer = actor 'Customer'
  saas = system 'Our SaaS' {
    component ui
    component backend
  }
}
```

### Relationships

We have at least these relationships:

```likec4 showLineNumbers {13,14,16,17} filename="getting-started.c4" 
specification {
  element actor
  element system
  element component
}

model {
  customer = actor 'Customer'
  saas = system 'Our SaaS' {
    component ui 
    component backend

    // UI requests data from the Backend
    ui -> backend

    // Customer uses the UI
    customer -> ui 'opens in browser'
  }
}
```

### Landscape view

View is a projection, a slice of the model defined by predicates (what to include/exclude).  
Let's add the Landscape view, i.e bird's eye view of the architecture.

```likec4 showLineNumbers copy {23-25} filename="getting-started.c4" 
specification {
  element actor
  element system
  element component
}

model {
  customer = actor 'Customer'
  saas = system 'Our SaaS' {
    component ui 
    component backend

    // UI requests data from the Backend
    ui -> backend

    // Customer uses the UI
    customer -> ui 'opens in browser'
  }
}

views {

  view index {    
    include *
  }

}
```

We got this:

![landscape view](/getting-started/01.png)

<Callout type="info">
  **Why there is a relationship?**

  The relationships are implied from the model.  
  `customer -> saas` is implied, because `customer` has the relationship with nested `saas.ui` element.  
  All "implied" relationships are merged together.
</Callout>

### Add more views

View may have a root element (`view of ...`) as initial scope

```likec4 showLineNumbers copy {27-29} filename="getting-started.c4" 
specification {
  element actor
  element system
  element component
}

model {
  customer = actor 'Customer'
  saas = system 'Our SaaS' {
    component ui 
    component backend

    // UI requests data from the Backend
    ui -> backend

    // Customer uses the UI
    customer -> ui 'opens in browser'
  }
}

views {

  view index {
    include *
  }

  view of saas {    
    include *
  }  

}
```

Imagine, we zoom-in and expand the `saas` element, look at nested elements and their relationships:

![saas view](/getting-started/02.png)

### Enrich the model

Let's add descriptions, define the shape of the `ui` and add label to the relationship `ui -> backend`

```likec4 showLineNumbers {9,13-24,27,43-45} copy filename="getting-started.c4" 
specification {
  element actor
  element system
  element component
}

model {
  customer = actor 'Customer' {
    description 'The regular customer of the system'
  }

  saas = system 'Our SaaS' {
    component ui 'Frontend' {
      description 'Nextjs application, hosted on Vercel'
      style {
        shape browser
      }
    }
    component backend 'Backend Services' {
      description '
        Implements business logic
        and exposes as REST API
      '
    }

    // UI requests data from the Backend
    ui -> backend 'fetches via HTTPS'

    // Customer uses the UI
    customer -> ui 'opens in browser'
  }
}

views {

  view index {
    include *
  }

  view of saas {    
    include *

    style customer {
      color muted
    }
  }  

}
```

The `saas` view after changes:

![saas view after changes](/getting-started/03.png)

And if we change any element/relationship - the change will be reflected everywhere.   
No more outdated diagrams


<Cards>
  <Card title="Open in playground" href={`/playground/getting-started/`} arrow/>
</Cards>

</Steps>
